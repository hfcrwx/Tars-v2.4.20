# Table of Contents
> * [TUP Overview](#main-chapter-1)
> * [TUP use](#main-chapter-2)
> * [Introduction to each version of the TUP interface](#main-chapter-3)

# 1. TUP Overview <a id="main-chapter-1"></a>

## 1.1. What is TUP?

TUP (short for Tars Uni-Protocol), the Tars unified protocol, is a package based on the command layer protocol of the Tars code.

## 1.2. What can TUP do?

1.Support java, c++ and other languages

2.Support for serialization and deserialization of objects

3.Support protocol dynamic expansion

4.Provide put/get generic interface to quickly implement client/server codec

5.Serialized data can be used for network transmission or persistent storage

6.Support the server that directly calls Tars

## 1.3. What can't TUP do?

1.Only protocol encapsulation, no network layer

2.Data compression is not supported (can be processed at the business layer)

3.Does not support encryption protocol (can be processed at the business layer)

## 1.4. Dependencies and constraints

1.Dependent on the Tars protocol, the structure object used by the TUP must be generated by the Tars definition.

2.Depends on the code generation tools of various languages, such as: tars2cpp/tars2java, etc.

3.Tars-related interfaces encapsulated in TarsUniPacket (such as getTars.../setTars...), only need to be used when calling Tars service

4.During use, use UniPacket to complete the request and the corresponding data transfer, where ServantName (service object name) and FuncName (interface name) are parameters that must be set, otherwise the encoding fails.

5.It is not recommended to get/put too much data. If there is more data, it is recommended to form a struct in the tars file and then put/get into UniPacket to improve efficiency and reduce network packet size.

6.The result of UniPacket encoding includes the packet length information of the 4-byte network byte order in the packet header, and the length includes the packet header. After receiving the packet, the receiver needs to judge the packet length according to the content of the packet header. Finally confirmed that the packet is complete and transmitted, we introduce the decoding interface to decode the packet.

7.Tars c++ language string type interface can not contain binary data, binary data is transmitted with vector<char>

# 2. TUP uses <a id="main-chapter-2"></a>

## 2.1. Class structure diagram

![tars](../docs/images/tars_tupclass.png)

## 2.2. Use of classes

1.RequestPacket: The base class of the request packet and the response packet is generated by the tars file definition, which is consistent with the basic package of the Tars service, and is generally not directly used.

2.UniAttribute: attribute class, the user may be performed by the object class operation, add properties and get property, class provides a put / get generic interface, can achieve encoding and decoding. The encoded serialized byte stream can be used for compression, encryption, network transmission or persistent storage, deserializing the original object when needed.

3.UniPacket: Request response packet class, inherited from UniAttribute, you can add the requested attribute value, set the remote object and method name to be requested, and send it to the server after encoding. After decoding, the server can obtain the attribute parameter for processing. After the server processes the request, the result is also returned by the object of the class, and the client decodes and obtains the processing result.

4.TarsUniPacket: Tars request response packet class, inherited from UniPacket, used when calling Tars remote service. After adding attributes and setting related attributes, the user encodes the request packets and sends them to the Tars service for processing. The Tars server receives the request of the TUP protocol, and returns the packet to the client after returning the packet with the object group of the class. After the client receives the packet, the class is used for decoding processing to obtain the result.

## 2.3. Calling the Tars service using the TUP protocol

1.When the client calls, the TarsUniPacket object is used to perform parameter setting of the request packet and input parameter assignment. The request parameter information that must be specified includes:
```
setRequestId(); set the message id, increment

setServantName(""); set the remote object name

setFuncName(""); set the remote interface name

setTarsPacketType(); package type version, TUP defaults to 3
```
For a specific remote interface call, you only need to assign the input parameters through the put interface. The property name is the parameter name defined by the tars interface, for example, for the interface:
```
int testFunc(string inputString, int inputInt, out string outputString);
```
The way to enter parameter assignments is:
```
TarsUniPacket<> req;

req.put<string>("inputString", "testInput");

req.put<Int32>("inputInt", 12345);

req.encode(buff);
```
The TarsUniPacket object must set the property value for each input parameter defined by tars. Otherwise, the server will return an exception error that lacks a certain property value when processing the request. The output parameter can also be used as input, but it is not required.

The template type of the 'put' interface is the corresponding type defined by the tars parameter, except for the enumeration type. Int32 is used as the template type to assign the attribute value.

2.The TUP return packet is also decoded using the TarsUniPacket object. After decoding, the getTarsResultCode() interface is used to obtain the processing result of the tars service. zero is successful, non-zero is failed, and the cause of the failure can be obtained through the getTarsResultDesc() interface.

The output parameters of the returned successful result packet are obtained by using the output parameter name defined by tars as the attribute name, and the return value of the interface is obtained by using the attribute name of the empty string.

The way the interface returns the result is as follows:
```
TarsUniPacket<> rsp;

rsp.decode(recvBuff, recvLen);

if(rsp.getTarsResultCode() == 0)
{
    int ret = rsp.get<int32_t>("");                                                                     / / Get the return value
    string retString = rsp.get<string>("outputString"); //Get the output parameters
}
else
{
    cout << rsp.getTarsResultDesc() << endl;
}
```
# 3. TUP version interface introduction <a id="main-chapter-3"></a>

## 3.1. Linux c++

### 3.1.1. Class interface

UniAttribute class

Public interface |function description
------|--------
template<typename T> void put(const string& name, const T& t) |Add attribute values
template<typename T> void get(const string& name, T& t)|Get the attribute value
template<typename T> T get(const string& name)|Get the attribute value
template<typename T> void getByDefault(const string& name, T& t, const T& def)|Get the attribute value (ignoring the exception, def is the default)
template<typename T> T getByDefault(const string& name, const T& def)|Get the attribute value (ignoring the exception, def is the default)
void clear()|Clear all attribute values
void encode(string& buff)|Encode attribute object to byte stream
void encode(vector<char>& buff)|Encode attribute object to byte stream
void encode(char* buff, size_t & len)|Encode attribute object to byte stream
void decode(const char* buff, size_t len)|decodes the byte stream
void decode(const vector<char>& buff)|decodes the byte stream
const map<string, vector<char> >& getData() const|Get existing attributes
bool isEmpty()|Judge whether the attribute set is empty
size_t size()|Get the attribute collection size
bool containsKey(const string & key)|Judge whether the attribute exists

UniPacket class

Public interface |function description
------|--------
void setVersion(short iVer) |Set protocol version number
UniPacket createResponse()| generates a response packet through the request packet, and the generation process retrieves the request ID, object name, method name, etc. from the request packet into the response packet.
void encode(string& buff)|Encode object to byte stream
void encode(vector<char>& buff)|Encode object to byte stream
void encode(char* buff, size_t & len)|Encode object to byte stream
void decode(const char* buff, size_t len)|Decodes the byte stream, where len is passed into the buffer length and the length of the decoded result is output.
tars::Short getVersion() const|Get protocol version number
tars::Int32 getRequestId() const|Get the message ID
void setRequestId(tars::Int32 value)|Set the request ID
const std::string& getServantName() const|Get the object name
void setServantName(const std::string& value)|Set the object name (the object name cannot be empty when encoding, otherwise the encoding will fail)
const std::string& getFuncName() const|Get method name
void setFuncName(const std::string& value)|Set the method name (the method name cannot be empty when encoding, otherwise the encoding will fail)

TarsUniPacket class

Public interface |function description
------|--------
void setTarsVersion(tars::Short value) |Set protocol version
void setTarsPacketType(tars::Char value)|Set the call type
void setTarsMessageType(tars::Int32 value)|Set the message type
void setTarsTimeout(tars::Int32 value)|Set timeout
void setTarsBuffer(const vector<tars::Char>& value)|Set parameter encoding content
void setTarsContext(const map<std::string, std::string>& value)|Set the context
void setTarsStatus(const map<std::string, std::string>& value)|Set the state value of the special message
tars::Short getTarsVersion() const|Get protocol version
tars::Char getTarsPacketType() const|Get the call type
tars::Int32 getTarsMessageType() const|Get the message type
tars::Int32 getTarsTimeout() const|Get timeout
const vector<tars::Char>& getTarsBuffer() const|Get the parameter encoded content
const map<std::string, std::string>& getTarsContext() const|Get context
const map<std::string, std::string>& getTarsStatus() const|Get the status value of a special message
tars::Int32 getTarsResultCode() const|Get the result code of the Tars service processing, 0 is successful, non-zero is failed
string getTarsResultDesc() const|Get the description of the Tars service processing result

### 3.1.2. Use caution

An error in the above interface call will throw a runtime_error exception.

### 3.1.3. Examples of use

See the sample program under cpp/test/testServant/testTup/

## 3.2. Java

### 3.2.1. Class interface

UniAttribute class

UniPacket class

TarsUniPacket class

### 3.2.2. Use caution

1. Currently TUP supports basic types, TarsStruct, which already stores basic types or TarsStruct maps and lists. Only support byte[] for arrays, and throwing IllegalArgumentException for other types;

2. The put and get method calls will throw an ObjectCreateException exception;

### 3.2.3. Examples of use
